import {
  Component,
  ChangeDetectionStrategy,
  signal,
  computed,
  inject,
  effect,
  input,
} from '@angular/core';
import { Modal, ModalContainer, ModalHeader, ModalContent, ModalFooter } from 'shared-ui';
import { Button, Input } from 'shared-ui';
import { ToastService } from 'shared-ui';
import { SpaceService } from '../../application/services/space.service';
import { TranslatePipe, TranslateService } from '@ngx-translate/core';

@Component({
  selector: 'app-create-space-modal',
  imports: [ModalContainer, ModalHeader, ModalContent, ModalFooter, Button, Input, TranslatePipe],
  template: `
    <lib-modal-container>
      <lib-modal-header>{{ 'spaces.modals.createSpace' | translate }}</lib-modal-header>
      <lib-modal-content>
        <form class="create-space-form" (ngSubmit)="handleSubmit()">
          <lib-input
            [label]="'spaces.modals.spaceName' | translate"
            [placeholder]="'spaces.modals.spaceNamePlaceholder' | translate"
            [(model)]="name"
            [required]="true"
            [errorMessage]="nameError()"
            [helperText]="'spaces.modals.spaceNameHelper' | translate"
          />
          <lib-input
            [label]="'spaces.modals.spaceKey' | translate"
            [placeholder]="'spaces.modals.spaceKeyPlaceholder' | translate"
            [(model)]="key"
            [errorMessage]="keyError()"
            [helperText]="'spaces.modals.spaceKeyHelper' | translate"
          />
          <lib-input
            [label]="'spaces.modals.description' | translate"
            type="textarea"
            [placeholder]="'spaces.modals.descriptionPlaceholder' | translate"
            [(model)]="description"
            [rows]="3"
            [helperText]="'spaces.modals.descriptionHelper' | translate"
          />
        </form>
      </lib-modal-content>
      <lib-modal-footer>
        <lib-button variant="secondary" (clicked)="handleCancel()" [disabled]="isSubmitting()">
          {{ 'common.cancel' | translate }}
        </lib-button>
        <lib-button
          variant="primary"
          (clicked)="handleSubmit()"
          [loading]="isSubmitting()"
          [disabled]="!isValid()"
        >
          {{ 'spaces.modals.createSpace' | translate }}
        </lib-button>
      </lib-modal-footer>
    </lib-modal-container>
  `,
  styles: [
    `
      @reference "#mainstyles";

      .create-space-form {
        @apply flex flex-col gap-4;
      }
    `,
  ],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class CreateSpaceModal {
  private readonly spaceService = inject(SpaceService);
  private readonly toast = inject(ToastService);
  private readonly modal = inject(Modal);
  private readonly translateService = inject(TranslateService);

  readonly organizationId = input.required<string>();

  readonly name = signal('');
  readonly key = signal('');
  readonly description = signal('');
  readonly isSubmitting = signal(false);

  readonly nameError = computed(() => {
    const value = this.name();
    if (!value.trim()) {
      return this.translateService.instant('spaces.modals.nameRequired');
    }
    if (value.trim().length < 3) {
      return this.translateService.instant('spaces.modals.nameMinLength');
    }
    return '';
  });

  readonly keyError = computed(() => {
    const value = this.key();
    if (!value.trim()) {
      return ''; // Key is optional, will be auto-generated
    }
    // Key format validation: uppercase letters and numbers only, max 10 chars
    const keyPattern = /^[A-Z0-9]+$/;
    if (!keyPattern.test(value)) {
      return this.translateService.instant('spaces.modals.keyInvalidFormat');
    }
    if (value.length > 10) {
      return this.translateService.instant('spaces.modals.keyMaxLength');
    }
    if (value.length < 2) {
      return this.translateService.instant('spaces.modals.keyMinLength');
    }
    return '';
  });

  readonly isValid = computed(() => {
    return !this.nameError() && !this.keyError() && this.name().trim();
  });

  private readonly lastAutoGeneratedKey = signal<string>('');
  private readonly keyManuallyEdited = signal(false);

  constructor() {
    // Auto-generate key when name changes (only if not manually edited)
    effect(() => {
      const nameValue = this.name();
      if (!nameValue || this.keyManuallyEdited()) {
        return;
      }

      const newKey = this.generateKey(nameValue);
      this.key.set(newKey);
      this.lastAutoGeneratedKey.set(newKey);
    });

    // Track when key is manually edited
    effect(() => {
      const keyValue = this.key();
      const lastAutoKey = this.lastAutoGeneratedKey();
      // If key differs from last auto-generated, mark as manually edited
      if (keyValue && lastAutoKey && keyValue !== lastAutoKey) {
        this.keyManuallyEdited.set(true);
      }
    });
  }

  /**
   * Auto-generate space key from space name
   * Max 10 characters, uppercase alphanumeric
   */
  private generateKey(name: string): string {
    const cleaned = name
      .toUpperCase()
      .trim()
      .replace(/[^A-Z0-9\s]/g, '') // Remove special characters
      .replace(/\s+/g, '') // Remove spaces
      .substring(0, 10); // Max 10 characters
    return cleaned || 'SPACE';
  }

  handleCancel(): void {
    this.modal.close();
  }

  async handleSubmit(): Promise<void> {
    if (!this.isValid()) {
      return;
    }

    this.isSubmitting.set(true);

    try {
      await this.spaceService.createSpace({
        name: this.name().trim(),
        key: this.key().trim() || undefined, // Let backend auto-generate if empty
        description: this.description().trim() || undefined,
        organization_id: this.organizationId(),
      });

      this.toast.success(this.translateService.instant('spaces.modals.createSuccess'));
      this.modal.close();

      // Reset form
      this.name.set('');
      this.key.set('');
      this.description.set('');
      this.lastAutoGeneratedKey.set('');
      this.keyManuallyEdited.set(false);

      // Spaces list will auto-reload via httpResource
    } catch (error) {
      console.error('Failed to create space:', error);
      const errorMessage =
        error instanceof Error
          ? error.message
          : this.translateService.instant('spaces.modals.createError');
      this.toast.error(errorMessage);
    } finally {
      this.isSubmitting.set(false);
    }
  }
}
